# Default values for zenml.

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""


# ZenML server related options.
zenml:

  replicaCount: 1

  # The number of ZenML server worker threads to use. This controls the number
  # of concurrent requests that each ZenML server pod/replica can handle at a
  # time. If not specified, the default value is 40.
  #
  # NOTE: this value should be coordinated with the `zenml.database.poolSize`
  # and `zenml.database.maxOverflow` values to ensure that the ZenML server
  # workers do not block on database connections (i.e. the sum of the pool size
  # and max overflow should be greater than or equal to the thread pool size).
  #
  # threadPoolSize: 40

  # The number of ZenML server threads that are dedicated to authentication.
  # This controls the number of concurrent requests that can be verified
  # concurrently. If not specified, the default value is 5.
  #
  # NOTE: this value should be coordinated with the `zenml.database.poolSize`
  # and `zenml.database.maxOverflow` values to ensure that the ZenML server
  # worker threads do not block on database connections (i.e. the sum of the
  # pool size and max overflow should be greater than or equal to the main
  # thread pool size plus the auth thread pool size).
  #
  # authThreadPoolSize: 5

  # The timeout in seconds after which a request is considered timed out by the
  # server if it takes too long to complete. After this time value, the server
  # will preemptively return a 429 status code (rate limit exceeded) to the
  # client to free up connections. If not specified, the default value is 30.
  #
  # NOTE: this values should be lower than the client's configured HTTP timeout
  # (which defaults at 30 seconds) to avoid the client timing out before the
  # server does. 
  #
  # requestTimeout: 20

  # Whether to cache request responses and use them to deduplicate retried
  # requests. If not specified, the default value is true. Only POST requests
  # and requests to endpoints that are known to incur longer processing times
  # at scale are cached and deduplicated.
  #
  # NOTE: don't disable this feature unless you know what you are doing. This is
  # crucial to ensure idempotency of POST requests.
  #
  # requestDeduplication: true

  # The timeout in seconds after which a cached request result is deleted.
  # If not specified, the default value is 300.
  #
  # requestCacheTimeout: 300

  image:
    repository: zenmldocker/zenml-server
    pullPolicy: Always
    # Overrides the image tag whose default is the chart appVersion.
    tag:

  # ZenML Pro related options.
  pro:
    # Set `enabled` to true to enable ZenML Pro servers. If set, some of the
    # configuration options in the `zenml` section will be overridden with
    # values specific to ZenML Pro servers computed from the values set in the
    # `pro` section.
    enabled: false

    # The URL where the ZenML Pro server API is reachable
    apiURL: https://cloudapi.zenml.io

    # The URL where the ZenML Pro dashboard is reachable.
    dashboardURL: https://cloud.zenml.io

    # Additional origins to allow in the CORS policy.
    extraCorsOrigins:

    # The ID of the ZenML Pro workspace to use.
    workspaceID:

    # The name of the ZenML Pro workspace to use.
    workspaceName:

    # The ID of the ZenML Pro organization to use.
    organizationID:

    # The name of the ZenML Pro organization to use.
    organizationName:

    # The enrollment key to use for the ZenML Pro workspace. If not specified,
    # an enrollment key will be auto-generated.
    enrollmentKey:

  # The URL where the ZenML server API is reachable. If not specified, the
  # clients will use the same URL used to connect them to the ZenML server.
  #
  # IMPORTANT: this value must be set for ZenML Pro servers.
  serverURL:

  # The URL where the ZenML dashboard is reachable.
  # If not specified, the `serverURL` value is used. This should be
  # configured if the dashboard is served from a different URL than the
  # ZenML server.
  #
  # This is value is used to compute the dashboard URLs during the web login
  # authentication workflow, to print dashboard URLs in log messages when
  # running a pipeline and for other similar tasks.
  #
  # This value is overridden if the `zenml.pro.enabled` value is set.
  dashboardURL:

  debug: true

  # Flag to enable/disable the tracking process of the analytics
  analyticsOptIn: true

  # ZenML server deployment type. This field is used for telemetry purposes.
  # Example values are "local", "kubernetes", "aws", "gcp", "azure".
  #
  # This value is overridden if the `zenml.pro.enabled` value is set.
  deploymentType:

  # Authentication settings that control how the ZenML server authenticates
  # its users.
  auth:

    # The ZenML authentication scheme. Use one of:
    # 
    # NO_AUTH - No authentication
    # HTTP_BASIC - HTTP Basic authentication
    # OAUTH2_PASSWORD_BEARER - OAuth2 password bearer
    # EXTERNAL - External authentication (e.g. via a remote authenticator)
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    authType: OAUTH2_PASSWORD_BEARER

    # The secret key used to sign JWT tokens. This should be set to
    # a random string with a recommended length of at least 32 characters, e.g.:
    #
    #   ```python
    #   from secrets import token_hex
    #   token_hex(32)
    #   ```
    #   
    # or:
    #
    #   ```shell
    #   openssl rand -hex 32
    #   ```
    #
    # If not explicitly set, a random key will be generated when the helm
    # chart is installed and reused for all subsequent upgrades.
    jwtSecretKey:

    # The JWT token algorithm to use. Use one of:
    # 
    # HS256 - HMAC using SHA-256 hash algorithm
    # HS384 - HMAC using SHA-384 hash algorithm
    # HS512 - HMAC using SHA-512 hash algorithm
    jwtTokenAlgorithm: HS256

    # The issuer of the JWT tokens. If not specified, the issuer is set to the
    # ZenML Server ID.
    jwtTokenIssuer:

    # The audience of the JWT tokens. If not specified, the audience is set to
    # the ZenML Server ID.
    jwtTokenAudience:
    
    # The leeway in seconds allowed when verifying the expiration time of JWT
    # tokens.
    jwtTokenLeewaySeconds: 10

    # The expiration time of JWT tokens in minutes. If not specified, generated
    # JWT tokens will not be set to expire.
    #
    # This value is automatically set if the `zenml.pro.enabled` value is set.
    jwtTokenExpireMinutes: 

    # The name of the http-only cookie used to store the JWT tokens used to
    # authenticate web clients. If not specified, the cookie name is set to a
    # value computed from the ZenML server ID.
    authCookieName:

    # The domain of the http-only cookie used to store the JWT tokens used to
    # authenticate web clients. If not specified, the cookie domain is set to
    # the domain of the ZenML server.
    authCookieDomain:

    # The origins allowed to make cross-origin requests to the ZenML server. If
    # not specified, all origins are allowed. Set this when the ZenML dashboard
    # is hosted on a different domain than the ZenML server.
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    corsAllowOrigins:
      - "*"

    # The maximum number of failed authentication attempts allowed for an OAuth
    # 2.0 device before the device is locked.
    #
    # This value is ignored if the `zenml.auth.authType` is set to `EXTERNAL` or
    # `NO_AUTH`.
    maxFailedDeviceAuthAttempts: 3

    # The timeout in seconds after which a pending OAuth 2.0 device
    # authorization request expires.
    #
    # This value is ignored if the `zenml.auth.authType` is set to `EXTERNAL` or
    # `NO_AUTH`.
    deviceAuthTimeout: 300

    # The polling interval in seconds used by clients to poll the OAuth 2.0
    # device authorization endpoint for the status of a pending device
    # authorization request.
    #
    # This value is ignored if the `zenml.auth.authType` is set to `EXTERNAL` or
    # `NO_AUTH`.
    deviceAuthPollingInterval: 5

    # The time in minutes that an OAuth 2.0 device is allowed to be used to
    # authenticate with the ZenML server. If not set or if
    # `zenml.auth.jwtTokenExpireMinutes` is not set, the devices are allowed to
    # be used indefinitely. This controls the expiration time of the JWT tokens
    # issued to clients after they have authenticated with the ZenML server
    # using an OAuth 2.0 device.
    #
    # This value is ignored if the `zenml.auth.authType` is set to `EXTERNAL` or
    # `NO_AUTH`.
    deviceExpirationMinutes:

    # The time in minutes that a trusted OAuth 2.0 device is allowed to be used
    # to authenticate with the ZenML server. If not set or if
    # `zenml.auth.jwtTokenExpireMinutes` is not set, the devices are allowed to
    # be used indefinitely. This controls the expiration time of the JWT tokens
    # issued to clients after they have authenticated with the ZenML server
    # using an OAuth 2.0 device that was previously trusted by the user.
    #
    # This value is ignored if the `zenml.auth.authType` is set to `EXTERNAL` or
    # `NO_AUTH`.
    trustedDeviceExpirationMinutes:

    # The login URL of an external authenticator service to use with the
    # `EXTERNAL` authentication scheme. Only relevant if `zenml.auth.authType`
    # is set to `EXTERNAL`.
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    externalLoginURL:

    # The user info URL of an external authenticator service to use with the
    # `EXTERNAL` authentication scheme. Only relevant if `zenml.auth.authType`
    # is set to `EXTERNAL`.
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    externalUserInfoURL:

    # The UUID of the ZenML server to use with the `EXTERNAL` authentication
    # scheme. If not specified, the regular ZenML server ID (deployment ID) is
    # used.
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    externalServerID:

    # Source pointing to a class implementing the RBAC interface defined by
    # `zenml.zen_server.rbac.rbac_interface.RBACInterface`. If not specified,
    # RBAC will not be enabled for this server.
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    rbacImplementationSource:

    # Source pointing to a class implementing the feature gate interface defined
    # by `zenml.zen_server.feature_gate.feature_gate_interface.FeatureGateInterface`.
    # If not specified, feature gating will not be enabled for this server.
    #
    # This value is overridden if the `zenml.pro.enabled` value is set.
    featureGateImplementationSource:

  # The root URL path to use when behind a proxy. This is useful when the
  # `rewrite-target` annotation is used in the ingress controller, e.g.:
  #
  # ```yaml
  # rootUrlPath: /zenml
  #
  # ingress:
  #   enabled: true
  #   className: "nginx"
  #   annotations:
  #     nginx.ingress.kubernetes.io/rewrite-target: /$1
  #   host:
  #   path: /zenml/?(.*)
  # ```
  rootUrlPath:

  defaultProject: default
  
  # Implicit authentication methods featured by service connectors that support
  # them are disabled by default, for security reasons. This is because they
  # allow users to authenticate to the cloud provider where ZenML is running
  # without having to provide any credentials.
  enableImplicitAuthMethods: false

  # MySQL database configuration. If not set, a local sqlite database will be
  # used. To ensure data are not lost, check the persistence part.
  # NOTE: the certificate files need to be copied in the helm chart folder and
  # the paths configured here need to be relative to the root of the helm chart.
  database:

    # If set to true, path where the local database is created will be
    # mounted as a persistent volume so the data is not lost on pod restarts.
    # Only relevant for local sqlite database.
    persistence:
      enabled: false
      size: 1Gi
      storageClassName: ""

    # The database URL. If not set, a local sqlite database will be used, which
    # will not be persisted across pod restarts. The URL can contain the
    # password or it can be provided in a secret using the `passwordSecretRef`
    # option.
    #
    # E.g.: "mysql://admin:password@zenml-mysql:3306/database"
    url: "mysql://${AWS_SQL_USERNAME}:${AWS_SQL_PASSWORD}@${AWS_SQL_HOST}:${AWS_SQL_PORT}/${AWS_SQL_DB_NAME}"

    # The Kubernetes secret containing the MySQL password. If not set, the
    # password provided in the `url` option will be used.
    passwordSecretRef:
      # name:
      # key:

    # Set to true to enable SSL for the MySQL database. Defaults to false.
    # NOTE: setting any of the SSL certificate options (sslCa, sslCert, sslKey)
    # will automatically set this option to true.
    ssl: false

    # The MySQL SSL CA certificate. Required for SSL enabled authentication if
    # the CA certificate is not part of the certificates shipped with the
    # container image. Can be provided as an inline value or as a Kubernetes
    # secret reference.
    #
    # NOTE: it is recommended to use the `zenml.certificates` option instead to
    # configure the CA certificate globally. This option only applies to the
    # MySQL database.
    sslCa:
      # value: |
      #   -----BEGIN CERTIFICATE-----
      #   ...
      #   -----END CERTIFICATE-----
      #
      # secretRef:
      #   name: ca-certificate
      #   key: ca.pem

    # The MySQL SSL client certificate. Required for SSL enabled authentication
    # if client certificates are used. Can be provided as an inline value or as
    # a Kubernetes secret reference.
    sslCert:
      # value: |
      #   -----BEGIN CERTIFICATE-----
      #   ...
      #   -----END CERTIFICATE-----
      #
      # secretRef:
      #   name: client-certificate
      #   key: client-cert.pem

    # The MySQL SSL client key. Required for SSL enabled authentication if
    # client certificates are used. Can be provided as an inline value or as
    # a Kubernetes secret reference.
    sslKey:
      # value: |
      #   -----BEGIN PRIVATE KEY-----
      #   ...
      #   -----END PRIVATE KEY-----
      #
      # secretRef:
      #   name: client-key
      #   key: client-key.pem

    # Set to true to verify the identity of the server against the provided
    # server certificate. Defaults to false.
    sslVerifyServerCert: false

    # Connection pool settings (only relevant for MySQL databases).
    #
    # NOTE: these values should be coordinated with the `zenml.threadPoolSize`
    # to ensure that the ZenML server workers do not block on database
    # connections (i.e. the sum of the pool size and max overflow should be
    # greater than or equal to the main thread pool size plus the auth thread
    # pool size).
    #
    # poolSize: 20
    # maxOverflow: 20

    # ZenML supports backing up the database before DB migrations are performed
    # and restoring it in case of a DB migration failure. For more information,
    # see the following documentation:
    # https://docs.zenml.io/getting-started/deploying-zenml/deploy-with-helm#database-backup-and-recovery
    #
    # Several backup strategies are supported:
    #
    # disabled - no backup is performed
    # in-memory - the database schema and data are stored in memory. This is
    #             the fastest backup strategy, but the backup is not persisted
    #             across pod restarts, so no manual intervention is possible
    #             in case the automatic DB recovery fails after a failed DB
    #             migration. Adequate memory resources should be allocated to
    #             the ZenML server pod when using this backup strategy with
    #             large databases.
    #             This is the default backup strategy.
    # dump-file - the database schema and data are dumped to a local file.
    #             Users may optionally configure a persistent volume where
    #             the dump file will be stored by setting the
    #             `backupPVStorageSize` and optionally the
    #             `backupPVStorageClass` options. If a
    #             persistent volume is not configured, the dump file will be
    #             stored in an emptyDir volume, which is not persisted.
    #             NOTE: you should set the podSecurityContext.fsGroup option
    #             if you are using a persistent volume to store the dump file.
    # database - the database is copied to a backup database in the same
    #            database server. This requires the `backupDatabase`
    #            option to be set to the name of the backup database.
    #            This backup strategy is only supported for MySQL
    #            compatible databases and the user specified in the
    #            database URL must have permissions to manage (create, drop, and
    #            modify) the backup database in addition to the main
    #            database.
    # mydumper - the database is backed up using mydumper/myloader. This
    #            requires the mydumper and myloader utilities to be installed
    #            in the ZenML server container. The `mydumperThreads`,
    #            `mydumperCompress`, `mydumperExtraArgs`, `myloaderThreads`,
    #            and `myloaderExtraArgs` options can be used to configure the
    #            backup and restore processes.
    # custom - use a custom backup engine. This requires the `customBackupEngine`
    #          option to be set to the class path of the custom backup engine.
    #          The class should extend from the `zenml.zen_stores.migrations.backup.base_backup_engine.BaseBackupEngine`
    #          base class and be importable from the container image that you
    #          are using for the ZenML server. Arguments for the custom backup engine
    #          can be passed using the `customBackupEngineConfig` option.
    #
    # backupStrategy: in-memory
    # backupPVStorageClass: standard
    # backupPVStorageSize: 1Gi
    # backupDatabase: "zenml_backup"
    #
    # mydumperThreads: 4
    # mydumperCompress: true
    # mydumperExtraArgs: []
    # myloaderThreads: 4
    # myloaderExtraArgs: []
    #
    # customBackupEngine: my.custom.backup.engine.MyCustomBackupEngine
    # customBackupEngineConfig:
    #   arg1: value1
    #   arg2: value2

  # Secrets store settings. This is used to store centralized secrets.
  secretsStore:

    # Set to false to disable the secrets store.
    enabled: true

    # The type of secrets store to use. Use one of:
    #
    # sql - Use the same SQL database as the ZenML server
    # aws - Use the AWS Secrets Manager as a secrets store
    # gcp - Use the GCP Secrets Manager as a secrets store
    # azure - Use the Azure Key Vault as a secrets store
    # hashicorp - Use the HashiCorp Vault as a secrets store
    # custom - Use a custom secrets store implementation (needs a custom
    #          ZenML server image with the custom secrets store implementation
    #          installed)
    #
    # Depending on the type, additional configuration options may be required
    # under the respective sections.
    #
    type: sql

    # SQL secrets store configuration. Only relevant if the `sql` secrets store
    # type is configured.
    sql:

      # The secret key used to encrypt secrets in the SQL database. Only relevant
      # if the SQL secrets store type is used. This should be set to a random
      # string with a recommended length of at least 32 characters, e.g.:
      #
      #   ```python
      #   from secrets import token_hex
      #   token_hex(32)
      #   ```
      #   
      # or:
      #
      #   ```shell
      #   openssl rand -hex 32
      #   ```
      #
      # If not set, database secret encryption will be disabled.
      #
      # IMPORTANT: If you configure encryption for your SQL database secrets
      # store, you should keep this value somewhere safe and secure, as it will be
      # required to decrypt the secrets in the database. If you lose the
      # encryption key, you will not be able to decrypt the secrets in the
      # database and will have to reset them. You should not change this value
      # after you have already configured encryption for your SQL database
      # secrets store.
      encryptionKey: "${TENANT_DEFAULT_ENCRYPTION_KEY}"

    # AWS secrets store configuration. Only relevant if the `aws` secrets store
    # type is configured.
    #
    # The AWS secrets store uses the AWS Service Connector under the hood to
    # authenticate with the AWS Secrets Manager API. This means that you can
    # use the same authentication methods and configuration as you would use for
    # the AWS Service Connector. Just set the `authMethod` field to the
    # authentication method that you want to use and set the required
    # configuration attributes under the `authConfig` field.
    # 
    # For a list of supported authentication methods and their configuration
    # options, see the following documentation:
    # https://docs.zenml.io/how-to/auth-management/aws-service-connector#authentication-methods
    # 
    # You can also use the ZenML CLI to get the list of supported authentication
    # methods and their configuration options, e.g.:
    #
    #   ```shell
    #   zenml service-connector describe-type aws
    #   zenml service-connector describe-type aws --auth-method secret-key
    #   ```
    aws:

      # The AWS Service Connector authentication method to use. The currently
      # supported authentication methods are:
      #
      # - implicit - Use the IAM role attached to the ZenML server pod or
      #              environment variables to authenticate with the AWS Secrets
      #              Manager API
      # - secret-key - Use an AWS secret key
      # - iam-role - Use an IAM role
      # - session-token - Use an AWS session token derived from an AWS secret
      #                   key
      # - federation-token - Use an AWS federation token derived from an AWS
      #                      secret key
      authMethod: secret-key

      # The AWS Service Connector authentication configuration. This should
      # include the corresponding authentication configuration attributes for
      # the `authMethod` that you have chosen above.
      authConfig:
        # The AWS region to use. This must be set to the region where the AWS
        # Secrets Manager service that you want to use is located. Mandatory
        # for all authentication methods.
        region:
        # The AWS access key and secret key to use to authenticate with the AWS
        # Secrets Manager instance. Both are required if the `authMethod` is set
        # to `secret-key`, `sts-token`, `iam-role`, or `federation-token`.
        aws_access_key_id:
        aws_secret_access_key:
        # The AWS role ARN to use to authenticate with the AWS Secrets Manager
        # instance. Required if the `authMethod` is set to `iam-role`. Optional
        # if the `authMethod` is set to `implicit`.
        role_arn:
        
      # The AWS region to use. This must be set to the region where the AWS
      # Secrets Manager service that you want to use is located.
      #
      # NOTE: deprecated; use `authConfig.region` instead.
      region_name:

      # The AWS credentials to use to authenticate with the AWS Secrets
      # Manager instance. You can omit these if you are running the ZenML server
      # in an AWS EKS cluster that has an IAM role attached to it that has
      # permissions to access the AWS Secrets Manager instance.
      #
      # NOTE: deprecated; use `authConfig.aws_access_key_id`,
      # and `authConfig.aws_secret_access_key` instead.
      aws_access_key_id:
      aws_secret_access_key:
      aws_session_token:


    # HashiCorp Vault secrets store configuration. Only relevant if the `hashicorp`
    # secrets store type is configured
    hashicorp:

      # The HashiCorp Vault authentication method to use. The currently
      # supported authentication methods are:
      #
      # - token - Use a static token
      # - app_role - Use a Vault App Role (app role ID and secret ID)
      # - aws - Use AWS authentication
      authMethod: ${VAULT_AUTH_METHOD}

      authConfig:

        # The url of the HashiCorp Vault server
        vault_addr: "${VAULT_ADDR}"
        # The Vault Enterprise namespace. Not required for Vault OSS.
        vault_namespace:
        # The mount point to use (defaults to "secret" if not set)
        mount_point: "${VAULT_MOUNT_POINT}"

        # Custom mount point to use for the authentication method.
        auth_mount_point:
        # The role ID to use for the app role authentication method. Required if
        # the authentication method is app_role.
        app_role_id:
        # The secret ID to use for the app role authentication method. Required
        # if the authentication method is app_role.
        app_secret_id:
        # The AWS role to use for the AWS authentication method. Relevant if the
        # authentication method is aws.
        aws_role: "${VAULT_AWS_ROLE}"
        # The AWS header value to use for the AWS authentication method. Relevant
        # if the authentication method is aws and the mount point enforces it.
        aws_header_value: "${VAULT_AWS_HEADER_VALUE}"
        # The token to use with the token authentication method. Required if the
        # authentication method is token.
        vault_token:
        # The maximum number of secret versions to keep. If not set, the default
        # value of 1 will be used (only the latest version will be kept).
        max_versions:

  # The ZenML server's secure headers configuration. This can be used to
  # enable, disable or set custom values for security headers in the ZenML
  # server's HTTP responses. The following values can be set for any of the
  # supported secure headers configuration options:
  #
  # - `enabled`, `on`, `true` or `yes` - enables the secure header with the
  # default value.
  # - `disabled`, `off`, `false`, `none` or `no` - disables the secure header
  # entirely, so that it is not set in the ZenML server's HTTP responses.
  # - any other value - sets the secure header to the specified value.  
  secure_headers:
    # The `Server` HTTP header value used to identify the server. The default
    # value is the ZenML server ID.
    server: enabled
    # The `Strict-Transport-Security` HTTP header value. The default value is
    # `max-age=63072000; includeSubDomains`.
    hsts: enabled
    # The `X-Frame-Options` HTTP header value. The default value is `SAMEORIGIN`.
    xfo: enabled
    # The `X-Content-Type-Options` HTTP header value. The default value is
    # `nosniff`.
    content: enabled
    # The `Content-Security-Policy` HTTP header value. This is by default set
    # to a strict CSP policy that only allows content from the origins required
    # by the ZenML dashboard.
    # NOTE: customizing this header is discouraged, as it may cause the ZenML
    # dashboard to malfunction.
    csp: enabled
    # The `Referrer-Policy` HTTP header value. The default value is
    # `no-referrer-when-downgrade`.
    referrer: enabled
    # The `Cache-Control` HTTP header value. The default value is
    # `no-store, no-cache, must-revalidate`.
    cache: enabled
    # The `Permissions-Policy` HTTP header value. The default value is
    # `accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()`.
    permissions: enabled


  # Extra environment variables to set in the ZenML server container.
  environment: {}

  # Extra environment variables to set in the ZenML server container that
  # should be kept secret. These will be set as Kubernetes secrets and
  # mounted as environment variables in the ZenML server container.
  secretEnvironment: {}

  # Custom 'app.kubernetes.io/instance' label value to use. This is used to
  # uniquely identify the ZenML deployment in the Kubernetes cluster. All
  # resources in the deployment will be labeled with this value, if set. The
  # label will also be used as a selector label for the ZenML server deployment
  # and database migration job.
  #
  # If not set, the default value will be the release name.
  #
  # It is recommended to set this value to a unique identifier in your cluster
  # to avoid conflicts with other ZenML deployments in the same cluster,
  # especially when using the same Helm release name for multiple deployments.
  # This can also be useful when used in conjunction with affinity rules.
  instanceLabel:

  service:
    type: ClusterIP
    port: 80
    annotations: {}

  ingress:
    enabled: true
    className: "nginx"
    annotations:
      # nginx.ingress.kubernetes.io/ssl-redirect: "true"
      # nginx.ingress.kubernetes.io/rewrite-target: /$1
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
      cert-manager.io/cluster-issuer: "letsencrypt"

    # hint: you can use a service like nip.io to get a wildcard DNS for your
    # ingress IP address. For example, if your ingress IP is 192.168.0.1, you
    # can use a host name like zenml.192.168.0.1.nip.io. This allows you to
    # reuse the same ingress for multiple deployments and/or services.
    host: zenml-amit.18.198.138.196.nip.io
    path: /
    tls:
      enabled: false
      # NOTE: if enabled, this will generate self-signed certificates during
      # installation. This also requires that the ingress host be set to the
      # domain name or IP address used to access the ZenML server from outside
      # the cluster.
      generateCerts: false
      secretName: zenml-amit-tls-certs

  # Configuration for custom CA certificates.
  certificates:

    # Direct injection of CA certificates in PEM format
    customCAs: []
      # - name: "my-custom-ca"
      #   certificate: |
      #     -----BEGIN CERTIFICATE-----
      #     MIIDXTCCAkWgAwIBAgIJAJC1HiIAZAiIMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV
      #     ...
      #     -----END CERTIFICATE-----
    
    # Reference existing secrets containing CA certificates
    secretRefs: []
      # - name: "my-secret"
      #   key: "ca.crt"

  # Proxy configuration
  proxy:
    # Enable proxy configuration
    enabled: false
    # HTTP proxy URL
    httpProxy: ""
    # HTTPS proxy URL
    httpsProxy: ""
    # Comma-separated list of hostnames/domains/IPs/CIDRs to exclude from proxying
    noProxy: "localhost,127.0.0.1,::1,fe80::/10,.svc,.svc.cluster.local"
    # Additional hostnames/domains/IPs/CIDRs to exclude from proxying
    additionalNoProxy: []

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: "zenml"

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 1000 # if you're using a PVC for backup, this should necessarily be set.

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  # capabilities:
  #   drop:
  #   - ALL

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

resourcesMigrationPod: {}
  # Resource requests and limits for the database migration pod.
  # If not set, falls back to the global resources configuration defined in .Values.resources

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}
